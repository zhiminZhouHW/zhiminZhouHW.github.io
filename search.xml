<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[经典排序]]></title>
    <url>%2F2019%2F05%2F06%2F%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;经典排序算法。 冒泡排序 冒泡排序：重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。（摘自百度百科） &emsp;&emsp;上面这段话是来自百度百科对冒泡排序的解释，简单点说就是一组数组从第一个元素开始，每次跟后面的所有元素做比较，如果比后面的数大（小）就交换位置，如此往复，一次循环后，最大（小）的数就被换到了数组的最后一位。这样最大（小）的数就找到了合适的位置，然后再从头开始，继续与最大（小）元素之前的所有元素做比较，直到找到第二大（小）的元素的合适位置。如此循环，最终所有的数都出现在合适的位置上，整个数组也就排好了序。 代码如下：123456789101112public void bubbleSort(int[] num) &#123; if (num == null || num.length == 0) &#123; return; &#125; for (int end = num.length - 1; end &gt; 0; end--) &#123; for (int i = 0; i &lt; end; i++) &#123; if (num[i] &gt; num[i+1]) &#123; swap(num, i, i+1); &#125; &#125; &#125; &#125; 这个是最简也是最基本的冒泡排序的写法，接下来我们想一想这段代码是否还有可以优化的地方。如果在某次循环没有发生一次数的交换，就说明数组已经排好序了，那么后面的循环比较就可以停止了。 改进代码如下：1234567891011121314151617public void bubbleSortModify(int[] num) &#123; if (num == null || num.length == 0) &#123; return; &#125; for (int end = num.length - 1; end &gt; 0; end--) &#123; boolean flag = false; for (int i = 0; i &lt; end; i++) &#123; if (num[i] &gt; num[i+1]) &#123; flag = true; swap(num, i, i+1); &#125; &#125; if (!flag) &#123; break; &#125; &#125;&#125; 选择排序 选择排序：选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。（摘自百度百科） &emsp;&emsp;选择排序其实就是从数组开头开始，遍历整个数组，通过比较选择最大（最小）的元素放在合适的位置。 代码如下：123456789101112public void selectionSort(int[] num) &#123; if (num == null || num.length &lt; 2) &#123; return; &#125; for (int i = 0; i &lt; num.length - 1; i++) &#123; int minIndex = i; for (int j = i+1; j &lt; num.length; j++) &#123; minIndex = num[j] &gt; num[minIndex]? minIndex : j; &#125; swap(num,i, minIndex); &#125;&#125; 插入排序 插入排序：插入排序（Insertion sort）是一种简单直观且稳定的排序算法。如果有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。（摘自百度百科） &emsp;&emsp;插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。 代码如下：12345678910public void insertionSort(int[] num) &#123; if (num == null || num.length &lt; 2) &#123; return; &#125; for (int i = 1; i &lt; num.length; i++) &#123; for (int j = i-1; j &gt;= 0 &amp;&amp; num[j+1] &lt; num[j]; j--) &#123; swap(num, j+1, j); &#125; &#125;&#125; 归并排序 归并排序：归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。（摘自百度百科） 代码如下：123456789101112131415161718192021222324252627282930313233343536public void mergeSort(int[] num) &#123; if (num == null || num.length &lt; 2) &#123; return; &#125; sortProcess(num, 0, num.length - 1); &#125; private void sortProcess(int[] num, int left, int right) &#123; if (left == right) &#123; return; &#125; int mid = left + ((right - left) &gt;&gt; 1); sortProcess(num, left, mid); sortProcess(num, mid+1, right); merge(num, left, mid, right); &#125; private void merge (int num[], int left, int mid, int right) &#123; int[] temp = new int[right - left + 1]; int i = 0; int leftIndex = left; int rightIndex = mid + 1; while(leftIndex &lt;= mid &amp;&amp; rightIndex &lt;= right) &#123; temp[i++] = num[leftIndex] &lt; num[rightIndex] ? num[leftIndex++] : num[rightIndex++]; &#125; while (leftIndex &lt;= mid)&#123; temp[i++] = num[leftIndex++]; &#125; while (rightIndex &lt;= right)&#123; temp[i++] = num[rightIndex++]; &#125; for (int j = 0; j &lt; temp.length; j++) &#123; num[j+left] = temp[j]; &#125; &#125; 快速排序 快速排序：快速排序由C. A. R. Hoare在1960年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。（摘自百度百科） 代码如下：123456789101112131415161718192021222324252627282930313233343536373839public void quickSort(int[] num) &#123; if (num == null || num.length &lt; 2) &#123; return; &#125; sort(num, 0, num.length - 1); &#125; public void sort(int[] num, int left, int right) &#123; if (left &lt; right) &#123; int[] p = partition(num, left, right); sort(num, left, p[0] - 1); sort(num, p[1] + 1, right); &#125; &#125; private int[] partition(int[] num, int left, int right) &#123; int less = left - 1; int more = right; while (left &lt; more) &#123; if (num[left] &lt; num[right]) &#123; swap(num, ++less , left++); &#125; else if (num[left] &gt; num[right]) &#123; swap(num, left, --more); &#125; else &#123; left++; &#125; &#125; swap(num, more, right); return new int[] &#123;less + 1, more&#125;; &#125; public void swap(int[] num, int i, int j) &#123; if (num == null || i == j) &#123; return; &#125; int temp = num[i]; num[i] = num[j]; num[j] = temp; &#125; 堆排序 堆排序：堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 1234567891011121314151617181920212223242526272829303132333435public void heapSort(int[] num) &#123; if (num == null || num.length &lt; 2) &#123; return; &#125; for (int i = 0; i &lt; num.length; i++) &#123; heapInsert(num, i); &#125; int len = num.length; swap(num, 0, --len); while (len &gt; 0) &#123; heapify(num, 0, len); swap(num, 0, --len); &#125;&#125;public void heapInsert (int[] num, int index) &#123; while (num[index] &gt; num[(index - 1)/2]) &#123; swap(num, index, (index - 1)/2); index = (index - 1)/2; &#125;&#125;public void heapify(int[] num, int index, int size) &#123; int left = index * 2 + 1; while (left &lt; size) &#123; int largest = (left + 1 &lt; size) &amp;&amp; num[left + 1] &gt; num[left] ? (left + 1) : left; largest = num[index] &gt; num[largest] ? index : largest; if (largest == index) &#123; break; &#125; swap(num, index, largest); index = largest; left = index * 2 + 1; &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上海生活]]></title>
    <url>%2F2019%2F05%2F02%2F%E4%B8%8A%E6%B5%B7%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;最近我的一个好朋友要买房子，之前他已经约了某家的中介看了一些房源。这次我正好趁着周末有空跟他一起去看了下，涨涨姿势。果然，在这次看房的过程中了解到了一些以前没有关注或者没有涉猎到的房产知识。 上海环线划分&emsp;&emsp;首先就是上海环线的划分，虽然之前也有听过上海内环、中环和外环的叫法，但其实对这个也只是有个模糊的概念而已。一般中介会问你想要买房的大概区域，内环、中环还是外环，因为他能根据你的回答判断出你想要买的价格区间以及你能接受的价位。所以我们得自己事先做好功课，了解一下这个常说的环线划分到底是怎么回事。&emsp;&emsp;我们先来看下下面这张图有个直观的概念。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>上海</tag>
        <tag>房产</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentHashMap学习]]></title>
    <url>%2F2019%2F05%2F01%2FConcurrentHashMap%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;HashMap学过Java的人肯定回经常接触到，但是ConcurrentHashMap估计很多人平时接触并不多，今天我们来了解一下。 HashMap原理&emsp;&emsp;HashMap的数据结构是：数组+链表。 ConcurrentHashMap原理]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
